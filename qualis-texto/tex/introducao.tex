% Comando simples para exibir comandos Latex no texto
\newcommand{\comando}[1]{\textbf{$\backslash$#1}}

% Poderia usar e citar alguns trechos de \cite{overview-blockchain-underwood2016} e \cite{overview-crosby2016blockchain}

% Em \cite{guo2021blockchain-bibliometric} há uma série de dados bibliométricos sobre tópicos, autores e tendências. 

% Segundo \citeonline{fu2019critical-02}, verificação formal é uma escolha adequada para CI com pequena dimensão, mas um design funcional complexo. O autor também faz algumas afirmações sobre outros estudos e ferramentas para verificação formal, execução simbólica e fuzzing.

Blockchain é o nome dado à tecnologia subjacente utilizada em diversas plataformas de gerenciamento descentralizado de posse de bens digitais baseada em livro-razão distribuído (do inglês, \sigla{DLT}{\textit{Distributed Ledger Technology}} )~\cite{kannengiesser2020trade-offs-acmcs}. Essa tecnologia tem como principais características o armazenamento descentralizado e distribuído, a imutabilidade, a transparência e a dispensa da necessidade de confiança em uma terceira parte ~\cite{fan2020performance, overview-dinh-2018}. O primeiro caso de êxito na aplicação da blockchain foi proposto por ~\citeonline{overview-bitcoin2008nakamoto}, que apresentou a Bitcoin, uma criptomoeda gerada e gerenciada de forma distribuída e sem entidades centralizadoras~\cite{zhang2019blockchain-security-acmcs}. A geração e o gerenciamento de posse de unidades de Bitcoin são realizados por uma rede de nós conectados auto-gerenciáveis que trabalham para manter a integridade do sistema~\cite{overview-dinh-2018}. 
%Esses bens digitais são chamados de criptomoedas, ou tokens~\cite{angelo2020tokens}.

A geração e gerenciamento de posse de criptomoedas é uma dentre diversas aplicações baseadas na DLT, ou seja, é apenas um fim para um meio~\cite{overview-blockchainbasic2018drescher}. Desde o seu surgimento, a blockchain tem passado por várias transformações, o que possibilitou sua aplicação em diversas áreas do conhecimento, como finanças, governo, Internet das Coisas, \sigla{IA}{inteligência artificial}, saúde, entre outras~\cite{swan2015blockchain-book, maesa2020blockchain3.0, zhu2019iot-applications, salah2019review-blockchain-ai, erikson2020survey-health}. 

Um fator crucial para impulsionar o avanço das DLTs foi a introdução dos ~\sigla{CI}{contratos inteligentes}~\cite{maesa2020blockchain3.0}. A plataforma baseada em DLT, Ethereum, proposta por~\citeonline{ethereum2014whitepaper}, possibilitou a execução de CIs de forma descentralizada em uma rede ponto-a-ponto (do inglês, \sigla{P2P}{\textit{peer-to-peer}}). Um CI consiste em um conjunto de cláusulas e condições, que são definidas entre as partes envolvidas e expressas por meio de uma linguagem de programação~\cite{overview-smartcontracts2020zheng}. Depois de escrito, o contrato é implantado em uma blockchain e executado de forma autônoma, automática, e imutável~\cite{overview-smartcontracts2020zheng, kannengiesser2020trade-offs-acmcs}. 

%Com a introdução dos CIs, expandiu-se o campo de aplicações da tecnologia blockchain, que passou a abranger aplicações descentralizadas (do inglês, \sigla{DApp}{\textit{Decentralized Applications}}), \sigla{OAD}{Organizações Autônomas Descentralizadas}, tokenização de bens e governança descentralizada~\cite{maesa2020blockchain3.0, monrat2019survey-blockchain-ieee, angelo2020tokens}. Além disso, as DLTs passaram a ser empregadas também para propor soluções e avanços em áreas como educação, cuidados médicos, \sigla{IoT}{\textit{Internet of things}}, indústria e inteligência artificial~\cite{casino2019block-app-survey-elsevier, salah2019review-blockchain-ai}.

Aplicações que executam sobre a plataforma Ethereum geralmente envolvem movimentações de grandes quantias de sua criptomoeda nativa, o Ether. Assim, essas aplicações tornaram-se alvos de diversos ataques que causaram transtornos e graves perdas financeiras~\cite{atzei2017survey-attacks-sok, chen2020survey-ethereum-acm}. O primeiro e um dos ataques mais conhecidos aconteceu em 2016 contra o \textit{The DAO} (sigla para \textit{Decentralized
Autonomous Organization}), um projeto de \textit{crowdfunding} que arrecadou cerca de 150 milhões de dólares~\cite{chen2020survey-ethereum-acm}. Neste ataque, um contrato malicioso explorou uma falha no código e transferiu cerca de 3,6 milhões de Ether para sua conta, o equivalente a 50 milhões de dólares~\cite{chen2020survey-ethereum-acm, siegel-dao-attack, atzei2017survey-attacks-sok}. 

Grande parte dos ataques deve-se à exploração de vulnerabilidades encontradas nos CIs~\cite{chen2020survey-ethereum-acm, atzei2017survey-attacks-sok, liu2019survey-ieeeaccess}. Devido à imutabilidade da blockchain, uma vez implantados, os CIs não podem ser alterados, e, portanto, não há como corrigir erros e vulnerabilidades contidos no código, o que ressalta a necessidade de identificá-los na fase de pré-implantação~\cite{vacca2020systematic, dika2018security}. Os CIs são geralmente escritos em Solidity~\footnote{Solidity documentation. ~\url{https://docs.soliditylang.org/en/develop/index.html}}, uma linguagem de programação de alto nível, Turing-completa, e desenvolvida especialmente para escrever CIs para a plataforma Ethereum~\cite{varela2021smart-languages-acmcs}.    Segundo~\citeonline{atzei2017survey-attacks-sok} parte desses erros são ocasionados pelo desalinhamento que há entre a semântica da linguagem Solidity e a intuição dos desenvolvedores.

Há uma série de vulnerabilidades descritas na literatura que são encontradas em CIs implantados na Ethereum~\cite{atzei2017survey-attacks-sok, chen2020survey-ethereum-acm, dika2018security}. No ataque cometido contra o \textit{The DAO}, conhecido como \textit{The DAO Attack}, foi explorada a vulnerabilidade de reentrância, que ocorre quando um contrato permite que uma função seja chamada recursivamente, mas o estado do contrato só é atualizado após a chamada. Na ocasião, uma função de saque do \textit{The DAO} foi invocada sucessivas vezes até esgotar todos os fundos do contrato, pois a atualização da variável que limitaria o quantidade a ser sacada só ocorria após a chamada recursiva~\cite{atzei2017survey-attacks-sok}. Outros ataques que ganharam notoriedade foram os cometidos contra a carteira multi-assinatura \textit{Parity Multsignature Wallet}, uma carteira de criptomoedas descentralizada na qual as transferências são realizadas mediante autorização de um grupo de usuários. Neste caso, um invasor se aproveitou de duas vulnerabilidades presentes no contrato: \textit{delegatecall injection}; e contrato suicida. A primeira permitiu que o invasor atribuísse a si mesmo a posse do contrato, que então transferiu 31 milhões de dólares em Ether para sua conta. Na última, mesmo após uma tentativa de correção do código da aplicação, o invasor novamente obteve a posse indevida do contrato, e em seguida invocou uma função para destruição do contrato, resultando no bloqueio permanente de 280 milhões de dólares em Ether associados às carteiras cadastradas~\cite{chen2020survey-ethereum-acm, destefanis2018smart-parity-wallet, knownattacks2018}. 

\section{Motivação}

Motivadas pela existência de riscos à segurança das aplicações baseadas em CIs, diversas estratégias foram utilizadas no intuito de mitigar os riscos envolvidos, como exposto nos trabalhos de~\citeonline{liu2019survey-ieeeaccess}, ~\citeonline{chen2020survey-ethereum-acm}, ~\citeonline{sayeed2020smart-attacks-ieee} e ~\citeonline{singh2020survey-vulnerabilities-elsevier}. Segundo ~\citeonline{dika2018security}, a forma mais efetiva para identificação de vulnerabilidades antes da implementação dos CIs é por meio da contratação de serviços de auditoria. Porém, tais serviços podem ser muito custosos para pequenas empresas e desenvolvedores individuais~\cite{dika2018security}. No estudo de ~\citeonline{chen2020survey-ethereum-acm}, ressalta-se que as duas melhores formas de prevenir-se de vulnerabilidades consistem na escrita de contratos livres de erros por meio de boas práticas de programação, e, em seguida, na utilização de analisadores ou verificadores de código.  

Na pesquisa de ~\citeonline{almakhour2020verification-survey}, as abordagens para verificação de CIs são separadas em dois aspectos: (i) verificação formal para correção; (ii) e detecção de vulnerabilidades para garantia de segurança. A verificação formal para correção consiste na representação formal do programa por meio de métodos matemáticos, denominado o processo de modelagem do programa. Uma vez modelado, propriedades que representam a ocorrência de vulnerabilidades ou de erros lógicos são definidas, e então um processo de verificação é executado em busca de violações das propriedades~\cite{almakhour2020verification-survey, singh2020survey-vulnerabilities-elsevier}. A detecção de vulnerabilidades para garantia de segurança baseia-se na definição de padrões de vulnerabilidades conhecidas para que, por meio de ferramentas, se execute uma análise sobre o código para então detectá-las~\cite{almakhour2020verification-survey}.

Tanto a garantia de segurança de CIs quanto a própria tecnologia blockchain representam áreas de pesquisa relativamente novas e emergentes~\cite{chen2020survey-ethereum-acm, kannengiesser2020trade-offs-acmcs}. Portanto, ainda não há uma abordagem ou ferramenta padronizadas para garantia de segurança dos CIs. Além disso, também há limitações nas abordagens existentes. As ferramentas para análise de código apresentam taxas consideráveis de falsos positivos e falsos negativos, e mostraram-se ineficientes para contratos complexos~\cite{kim2020automated-test-sc}. As técnicas de verificação formal são baseadas em métodos formais, e costumam exigir conhecimento especializado para modelagem matemática dos contratos, além de limitações de tempo e memória~\cite{chen2020survey-ethereum-acm}. 

Desta forma, técnicas para verificação formal são aplicadas geralmente em sistemas críticos, em que falhas podem levar à graves prejuízos, como no caso dos CIs. Ademais, a verificação formal possui maior precisão, e também pode ser utilizada para detecção de vulnerabilidades, identificadas por meio da violação de propriedades predeterminadas~\cite{wang2020formal-04, nelaturu2020verified-101, alt2018smt-87, wang2019detecting-nondeterministic-26}. Um dos métodos formais mais utilizados é o \textit{model checking}, no qual um sistema ou um \textit{software} é representado como um modelo de transição de estados, e então é realizada uma pesquisa exaustiva sobre todo o espaço de estados do sistema para verificar se o modelo age de acordo com propriedades predefinidas. Em caso de violação de uma propriedade, é fornecido um contra-exemplo com o caminho de execução realizado até a violação~\cite{clarke2018model, peled2019formal-methods}. 

Este trabalho é motivado pelos problemas relacionados a exploração de vulnerabilidades em CIs escritos em Solidity na blockchain Ethereum, assim como pelas limitações presentes nas abordagens existentes para mitigação destes problemas. Esta pesquisa tem o propósito de explorar este tema, tendo como base a seguinte questão de pesquisa:

\textit{``Como detectar as vulnerabilidades de reentrância, \textit{delegatecall injection} e contrato suicida, em CIs escritos na linguagem Solidity na fase de pré-implementação?''}

%Assim, diversas abordagens e formas de representação foram propostas para aprimorar a segurança dos CIs~\cite{liu2019survey-ieeeaccess, singh2020survey-vulnerabilities-elsevier, chen2020survey-ethereum-acm}, tais como: prova de teoremas; execução simbólica; \textit{model-checking}; modelagem formal; máquina de estados finito; modelagem comportamental; raciocínio formal; linguagens de especificação; análise semântica; e verificação em tempo real.


%A verificação formal é baseada em métodos formais, e, assim, conta com representações formais e métodos matemáticos para verificação~\cite{almakhour2020verification-survey}. Com a verificação formal, pode-se expressar, por exemplo, propriedades que visam detectar vulnerabilidades presentes nos programas.

%Em ferramentas para verificação e análise de vulnerabilidades a detecção de vulnerabilidades é ineficiente para análise de CIs mais complexos, pois várias vulnerabilidades podem ser ignoradas, já que não é uma análise exaustiva como nas técnicas de verificação formal~\cite{almakhour2020verification-survey}. Este fato também é destacado no estudo desenvolvido por ~\citeonline{kim2020automated-test-sc}. 


\section{Objetivos gerais e específicos}

Guiado pela questão de pesquisa, este trabalho tem como objetivo propor uma estratégia para verificação formal para aprimoramento de segurança aplicada na fase de pré-implementação de CIs escritos em Solidity para detecção das vulnerabilidades de reentrância, \textit{delegatecall injection} e contrato suicida, por meio da técnica de \textit{model checking}. Os objetivos específicos para se atingir o propósito deste trabalho são:
\begin{itemize}
    \item Determinar o formalismo adequado para modelagem dos contratos e para representação das vulnerabilidades;
    \item Implementar o método de verificação;
    \item Definir as estratégias para validação da proposta. 
\end{itemize}

\section{Organização do trabalho}

Este documento foi organizado da seguinte forma. No Capítulo~\ref{cap:fundamentacao} é apresentado o referencial teórico e os conceitos empregados neste trabalho. O Capítulo~\ref{cap:revisao} expõe como a pesquisa foi conduzida e quais foram os métodos aplicados para levantar os trabalhos e responder às questões de pesquisa. O Capítulo~\ref{cap:proposta} retrata os detalhes do método para verificação de CIs proposto, os trabalhos relacionados com a proposta desta pesquisa, e, por fim, o plano de trabalho elaborado. 

%%%%%% ANOTAÇÕES IMPORTANTES
%No trabalho de ~\cite{weiss2019annotary}, conseguiram avançar o estado da arte no que diz respeito à limitação encontrados em outras abordagens de verificar vulnerabilidades que envolvem análise de interação entre 2 ou mais contratos e sobre análise de cadeias de transações. Porém as questões a serem verificadas dependem de anotações feitas no código pelo próprio desenvolvedor, o que ainda ignora o fato que muitas vezes a falta de entendimento do próprio desenvolvedor sobre a linguagem é que ocasiona vulnerabilidades no código.